<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Happy Birthday!</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600&family=Montserrat:wght@400;500;700&family=Bangers&family=Indie+Flower&family=Architects+Daughter&family=Pacifico&family=Comic+Neue:wght@400;700&family=Permanent+Marker&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Montserrat', sans-serif;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="%23ff69b4"><circle cx="12" cy="12" r="10" fill="%23ff69b4" opacity="0.6"/></svg>') 12 12, auto;
        }
        
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s ease-out;
        }
        
        #loading-text {
            color: #fff;
            font-size: 3rem;
            text-align: center;
            font-family: monospace;
        }
        
        #birthday-message {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #fff;
    font-size: 3.5rem; /* Increased font size for better visibility */
    /* Font-family will be set dynamically in JavaScript */
    font-weight: 700; /* Bolder weight for better readability */
    text-align: center;
    z-index: 100;
    text-shadow: 0 0 20px rgba(255, 0, 255, 0.9), 0 0 30px rgba(0, 255, 255, 0.9), 0 2px 5px rgba(0, 0, 0, 1); /* Enhanced shadow for better contrast */
    animation: pulse 2s infinite;
    white-space: nowrap;
    letter-spacing: 1px;
}
        
        #birthday-subtext {
    position: absolute;
    top: calc(50% + 5rem);
    left: 50%;
    transform: translate(-50%, 0);
    color: #fff;
    font-size: 1.3rem; /* Increased font size for better visibility */
    /* Font-family will be set dynamically in JavaScript */
    font-weight: 600; /* Bolder weight for better readability */
    text-align: center;
    z-index: 100;
    text-shadow: 0 0 15px rgba(255, 0, 255, 0.9), 0 0 20px rgba(0, 255, 255, 0.9), 0 2px 4px rgba(0, 0, 0, 1); /* Enhanced shadow for better contrast */
    opacity: 0;
    transition: opacity 2s ease-in-out;
}
        
        /* Color cycle animations for name letters */
        @keyframes colorCycle1 {
            0% { color: inherit; }
            25% { color: #FF5252; }
            50% { color: #52BDFF; }
            75% { color: #52FF7A; }
            100% { color: inherit; }
        }
        
        @keyframes colorCycle2 {
            0% { color: inherit; }
            25% { color: #FF9A52; }
            50% { color: #7A52FF; }
            75% { color: #228B22; }
            100% { color: inherit; }
        }
        
        @keyframes colorCycle3 {
            0% { color: inherit; }
            25% { color: #FF52A3; }
            50% { color: #00BFFF; }
            75% { color: #FFBD52; }
            100% { color: inherit; }
        }
        
        @keyframes colorCycle4 {
            0% { color: inherit; }
            25% { color: #FF77FF; }
            50% { color: #B0E0E6; }
            75% { color: #ADFF2F; }
            100% { color: inherit; }
        }
        
        #start-button {
            position: absolute;
            top: calc(50% + 10rem);
            left: 50%;
            transform: translate(-50%, 0);
            padding: 15px 30px;
            background: linear-gradient(45deg, #ff00ff, #00ffff);
            color: white;
            border: none;
            border-radius: 50px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            z-index: 101;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.8);
            transition: all 0.3s ease;
        }
        
        #start-button:hover {
            transform: translate(-50%, 0) scale(1.1);
            box-shadow: 0 0 30px rgba(255, 0, 255, 1);
        }
        
        #start-button.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        
        .cat {
            position: absolute;
            z-index: 10;
            pointer-events: none;
            transform-origin: center;
            filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.7));
        }
        
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            z-index: 5;
            pointer-events: none;
        }
        
        #volume-control {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 200;
            display: flex;
            align-items: center;
            opacity: 0.3;
            transition: opacity 0.3s ease;
        }
        
        #volume-control:hover {
            opacity: 1;
        }
        
        #volume-slider {
            width: 100px;
            margin-left: 10px;
            -webkit-appearance: none;
            height: 5px;
            border-radius: 5px;
            background: linear-gradient(to right, #ff00ff, #00ffff);
            outline: none;
        }
        
        #volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.8);
        }
        
        #volume-icon {
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
        }
        
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); text-shadow: 0 0 15px rgba(255, 0, 255, 0.8), 0 0 25px rgba(0, 255, 255, 0.8); }
            50% { transform: translate(-50%, -50%) scale(1.1); text-shadow: 0 0 25px rgba(255, 0, 255, 1), 0 0 35px rgba(0, 255, 255, 1); }
            100% { transform: translate(-50%, -50%) scale(1); text-shadow: 0 0 15px rgba(255, 0, 255, 0.8), 0 0 25px rgba(0, 255, 255, 0.8); }
        }
        
        @keyframes float {
            0% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(5deg); }
            100% { transform: translateY(0px) rotate(0deg); }
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <div id="loading-text">:D</div>
    </div>
    
    <div id="birthday-message">Happy Birthday!</div>
    <div id="birthday-subtext" style="opacity: 0;"></div>
    <canvas id="canvas"></canvas>
    
    <div id="volume-control">
        <span id="volume-icon">ðŸ”Š</span>
        <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="0.7">
    </div>
    
    <audio id="bgMusic" loop>
        <!-- Add your music file here -->
        <source src="music.mp3" type="audio/mp3">
    </audio>
    
    <script>
        // Wait for the page to load
        window.addEventListener('load', function() {
            // Hide loading screen after all resources are loaded
            setTimeout(function() {
                const loadingScreen = document.getElementById('loading-screen');
                loadingScreen.style.opacity = '0';
                setTimeout(function() {
                    loadingScreen.style.display = 'none';
                }, 500);
            }, 1000); // Wait 1 second before hiding loading screen to ensure everything is ready
            const birthdayMessage = document.getElementById('birthday-message');
            const birthdaySubtext = document.getElementById('birthday-subtext');
            const audio = document.getElementById('bgMusic');
            const volumeSlider = document.getElementById('volume-slider');
            const volumeIcon = document.getElementById('volume-icon');
            
            // Array of font families to randomly choose from
            const fontFamilies = [
                // Professional, readable fonts
                "'Fredoka', sans-serif",
                "'Montserrat', sans-serif",
                // Goofy, playful fonts
                "'Bangers', cursive",          // Comic book style, very bold
                "'Indie Flower', cursive",     // Handwritten style
                "'Comic Neue', cursive",       // Improved Comic Sans
                "'Permanent Marker', cursive", // Marker pen style
                "'Architects Daughter', cursive" // Childlike handwriting
            ];
            
            // Set initial random font
            const initialFont = fontFamilies[Math.floor(Math.random() * fontFamilies.length)];
            birthdayMessage.style.fontFamily = initialFont;
            birthdaySubtext.style.fontFamily = initialFont;
            
            // Array of names to randomly display
            const birthdayNames = [
                "chleroe",
                "cloeueueiei",
                "goweee",
                "chowed",
                "choekopia",
                "chambodia",
                "chlochlo",
                "chloblem",
                "cleowes",
                "chlombustions",
                "chloas",
                "chlochle",
                "wowee",
                "chlorchlor",
                "crowe",
                "crowie",
                "Chlorehnagi",
                "Croe",
                "Chloer",
                "Chlorby",
                "c",
                "Calro",
                "Chroe",
                "Chskao",
                "Chlorbbb",
                "Chloring",
                "CHL",
                "chloraiowhtralwo",
                "Chlorbury",
                "Chalorie",
                "Chlorine",
                "Sodium chloride",
                "Chlroere",
                "Chlor",
                "Chalorski",
                "Chlornana",
                "Ornana"
            ];
            
            // Color palettes for different names
            const colorPalettes = {
                // Warm colors (reds, oranges, yellows)
                warm: ['#FF5252', '#FF7752', '#FF9A52', '#FFBD52', '#FFE052'],
                // Cool colors (blues, purples)
                cool: ['#52BDFF', '#527AFF', '#7A52FF', '#BD52FF', '#E052FF'],
                // Nature colors (greens, blues)
                nature: ['#52FF7A', '#52FFBD', '#52FFE0', '#52E0FF', '#52BDFF'],
                // Sunset colors
                sunset: ['#FF5252', '#FF527A', '#FF52A3', '#FF52CC', '#FF52F5'],
                // Ocean colors
                ocean: ['#0077BE', '#009ACD', '#00BFFF', '#87CEEB', '#B0E0E6'],
                // Forest colors
                forest: ['#228B22', '#32CD32', '#90EE90', '#98FB98', '#ADFF2F'],
                // Candy colors
                candy: ['#FF77FF', '#FF5252', '#FFBD52', '#52FFBD', '#527AFF'],
                // Pastel colors
                pastel: ['#FFB6C1', '#FFD700', '#FFDAB9', '#98FB98', '#87CEFA']
            };
            
            // Map names to color palettes
            const namePaletteMap = {};
            const paletteNames = Object.keys(colorPalettes);
            
            // Assign a palette to each name
            birthdayNames.forEach((name, index) => {
                const paletteIndex = index % paletteNames.length;
                namePaletteMap[name] = paletteNames[paletteIndex];
            });
             
             // Function to update birthday message with random name, font, and colorful letters
            function updateBirthdayMessage() {
                const randomIndex = Math.floor(Math.random() * birthdayNames.length);
                const name = birthdayNames[randomIndex];
                const palette = colorPalettes[namePaletteMap[name]];
                
                // Choose a random font for this update
                const fontIndex = Math.floor(Math.random() * fontFamilies.length);
                const randomFont = fontFamilies[fontIndex];
                birthdayMessage.style.fontFamily = randomFont;
                birthdaySubtext.style.fontFamily = randomFont;
                
                // Apply additional styling based on the font
                if (fontIndex <= 1) {
                    // Professional fonts - normal styling
                    birthdayMessage.style.letterSpacing = '0px';
                    birthdayMessage.style.transform = 'rotate(0deg)';
                    birthdaySubtext.style.letterSpacing = '0px';
                    birthdaySubtext.style.transform = 'rotate(0deg)';
                } else if (fontIndex === 2) {
                    // Bangers - comic style
                    birthdayMessage.style.letterSpacing = '2px';
                    birthdayMessage.style.transform = 'rotate(0deg)';
                    birthdaySubtext.style.letterSpacing = '1px';
                    birthdaySubtext.style.transform = 'rotate(0deg)';
                } else if (fontIndex === 3) {
                    // Indie Flower - slight tilt
                    birthdayMessage.style.letterSpacing = '0px';
                    birthdayMessage.style.transform = 'rotate(-1deg)';
                    birthdaySubtext.style.letterSpacing = '0px';
                    birthdaySubtext.style.transform = 'rotate(-1deg)';
                } else if (fontIndex === 4) {
                    // Comic Neue - normal
                    birthdayMessage.style.letterSpacing = '0px';
                    birthdayMessage.style.transform = 'rotate(0deg)';
                    birthdaySubtext.style.letterSpacing = '0px';
                    birthdaySubtext.style.transform = 'rotate(0deg)';
                } else if (fontIndex === 5) {
                    // Permanent Marker - wider spacing
                    birthdayMessage.style.letterSpacing = '1px';
                    birthdayMessage.style.transform = 'rotate(1deg)';
                    birthdaySubtext.style.letterSpacing = '0.5px';
                    birthdaySubtext.style.transform = 'rotate(1deg)';
                } else {
                    // Architects Daughter - slight tilt other way
                    birthdayMessage.style.letterSpacing = '0px';
                    birthdayMessage.style.transform = 'rotate(1deg)';
                    birthdaySubtext.style.letterSpacing = '0px';
                    birthdaySubtext.style.transform = 'rotate(1deg)';
                }
                
                // Clear previous content
                birthdayMessage.innerHTML = 'Happy Birthday ';
                
                // Create colorful name
                const nameSpan = document.createElement('span');
                nameSpan.style.fontWeight = 'bold';
                
                // Add each letter with its own color
                for (let i = 0; i < name.length; i++) {
                    const letterSpan = document.createElement('span');
                    const colorIndex = i % palette.length;
                    letterSpan.textContent = name[i];
                    letterSpan.style.color = palette[colorIndex];
                    letterSpan.style.textShadow = '0 0 12px rgba(255,255,255,0.9), 0 0 4px rgba(0,0,0,0.8), 0 0 8px ' + palette[colorIndex]; // Enhanced shadow with color glow
                    letterSpan.style.transition = 'color 0.5s';
                    letterSpan.style.display = 'inline-block';
                    letterSpan.style.letterSpacing = '2px'; // Increased letter spacing
                    letterSpan.style.fontWeight = '800'; // Extra bold
                    
                    // Add animation to change colors
                    setTimeout(() => {
                        letterSpan.style.animation = `colorCycle${randomIndex % 4 + 1} 2s infinite`;
                    }, i * 100);
                    
                    nameSpan.appendChild(letterSpan);
                }
                
                birthdayMessage.appendChild(nameSpan);
                birthdayMessage.innerHTML += '!';
            }
            
            // Update message initially and then every 1.1 seconds
updateBirthdayMessage();
setInterval(updateBirthdayMessage, 1100);
            
            // Set initial volume
            audio.volume = volumeSlider.value;
            
            // Volume control
            volumeSlider.addEventListener('input', function() {
                audio.volume = this.value;
                updateVolumeIcon(this.value);
            });
            
            volumeIcon.addEventListener('click', function() {
                if (audio.volume > 0) {
                    audio.volume = 0;
                    volumeSlider.value = 0;
                    updateVolumeIcon(0);
                } else {
                    audio.volume = 0.7;
                    volumeSlider.value = 0.7;
                    updateVolumeIcon(0.7);
                }
            });
            
            function updateVolumeIcon(volume) {
                if (volume > 0.5) {
                    volumeIcon.textContent = 'ðŸ”Š';
                } else if (volume > 0) {
                    volumeIcon.textContent = 'ðŸ”‰';
                } else {
                    volumeIcon.textContent = 'ðŸ”‡';
                }
            }
            
            // Start party automatically
            function startParty() {
                // Play music
                if (audio.paused) {
                    audio.play().catch(error => {
                        console.error('Audio play failed:', error);
                        // Add click event listener if autoplay fails (common on mobile)
                        document.addEventListener('click', function audioStartHandler() {
                            audio.play();
                            document.removeEventListener('click', audioStartHandler);
                        }, { once: true });
                    });
                }
                
                // Create confetti
                createConfetti();
            }
            
            // Start automatically
            setTimeout(startParty, 500);
            
            // Set up canvas for visualizer
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Audio context for visualizer
            let audioContext;
            let analyser;
            let audioSource;
            let dataArray;
            
            // Set up audio analyzer when music plays
            audio.addEventListener('play', function() {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    audioSource = audioContext.createMediaElementSource(audio);
                    analyser = audioContext.createAnalyser();
                    
                    audioSource.connect(analyser);
                    analyser.connect(audioContext.destination);
                    
                    analyser.fftSize = 256;
                    const bufferLength = analyser.frequencyBinCount;
                    dataArray = new Uint8Array(bufferLength);
                    
                    // Start animation
                    animate();
                }
            });
            
            // Cat images array - will be populated
            const cats = [];
            const catCount = 50; // Number of cats to display
            
            // Create cat elements
            for (let i = 0; i < catCount; i++) {
                createCat();
            }
            
            function createCat() {
                const cat = document.createElement('img');
                cat.className = 'cat';
                // Reference cat images directly from root directory
                cat.src = `cat${Math.floor(Math.random() * 5) + 1}.png`; // Using PNG cat images
                cat.style.width = `${Math.random() * 100 + 50}px`;
                cat.style.opacity = Math.random() * 0.7 + 0.3;
                
                // Random initial position
                cat.style.left = `${Math.random() * 100}vw`;
                cat.style.top = `${Math.random() * 100}vh`;
                
                // Store velocity for animation (reduced speed for slower movement)
                cat.vx = Math.random() * 2.5 - 1.25; // Reduced from 4 to 2.5
                cat.vy = Math.random() * 2.5 - 1.25; // Reduced from 4 to 2.5
                cat.rotation = 0;
                cat.rotationSpeed = Math.random() * 1.5 - 0.75; // Reduced rotation speed
                
                document.body.appendChild(cat);
                cats.push(cat);
            }
            
            // Create confetti particles
            function createConfetti() {
                const confettiCount = 100; // Reduced confetti count for better performance
                const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];
                
                for (let i = 0; i < confettiCount; i++) {
                    setTimeout(() => {
                        const confetti = document.createElement('div');
                        confetti.className = 'confetti';
                        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                        // Distribute across the entire screen width
                        confetti.style.left = `${Math.random() * window.innerWidth}px`;
                        confetti.style.top = '-10px';
                        confetti.style.width = `${Math.random() * 10 + 5}px`;
                        confetti.style.height = `${Math.random() * 10 + 5}px`;
                        confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
                        confetti.style.opacity = Math.random() * 0.8 + 0.2;
                        
                        // Store velocity and rotation for animation
                        confetti.vx = Math.random() * 2 - 1;
                        confetti.vy = Math.random() * 3 + 2;
                        confetti.rotation = 0;
                        confetti.rotationSpeed = Math.random() * 10 - 5;
                        
                        document.body.appendChild(confetti);
                        
                        // Remove after animation completes
                        setTimeout(() => {
                            confetti.remove();
                        }, 10000);
                    }, i * 50); // Stagger confetti creation
                }
                
                // Schedule next batch of confetti more frequently
                setTimeout(createConfetti, 3000); // Create new confetti every 3 seconds
            }
            
            // Animation function
            function animate() {
                requestAnimationFrame(animate);
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Update visualizer regardless of whether music is playing or not
                // This ensures visualization even when volume is low or muted
                if (audioContext) {
                    analyser.getByteFrequencyData(dataArray);
                    
                    // Get time domain data for waveform
                    const timeDataArray = new Uint8Array(analyser.frequencyBinCount);
                    analyser.getByteTimeDomainData(timeDataArray);
                    
                    // Create default values for visualization when audio is low/muted
                    let bassAvg, midAvg, trebleAvg;
                    
                    if (!audio.paused) {
                        // Get actual audio data when playing
                        bassAvg = dataArray.slice(0, 10).reduce((a, b) => a + b, 0) / 10;
                        midAvg = dataArray.slice(10, 20).reduce((a, b) => a + b, 0) / 10;
                        trebleAvg = dataArray.slice(20, 30).reduce((a, b) => a + b, 0) / 10;
                    } else {
                        // Use default values when paused
                        bassAvg = 200;
                        midAvg = 180;
                        trebleAvg = 160;
                    }
                    
                    // Ensure minimum values for visualization even when volume is low
                    bassAvg = Math.max(bassAvg, 150);
                    midAvg = Math.max(midAvg, 130);
                    trebleAvg = Math.max(trebleAvg, 110);
                    
                    const bassIntensity = bassAvg / 255; // Normalized 0-1
                    const midIntensity = midAvg / 255;
                    const trebleIntensity = trebleAvg / 255;
                    
                    // Create gradient background that covers the full width
                    const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                    gradient.addColorStop(0, `rgba(0, ${Math.floor(255 * bassIntensity)}, ${Math.floor(255 * midIntensity)}, 0.2)`);
                    gradient.addColorStop(0.5, `rgba(${Math.floor(255 * midIntensity)}, ${Math.floor(255 * bassIntensity)}, ${Math.floor(255 * trebleIntensity)}, 0.2)`);
                    gradient.addColorStop(1, `rgba(${Math.floor(255 * trebleIntensity)}, 0, ${Math.floor(255 * midIntensity)}, 0.2)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw visualizer bars with guaranteed edge coverage
                    // Use fewer bars for better performance and wider spacing
                    const useBars = Math.min(32, dataArray.length); // Reduced number of bars to prevent overlapping
                    const barWidth = 10; // Narrower bar width to prevent overlapping
                    
                    // Draw bars across the full width with special handling for edges
                    for (let i = 0; i < useBars; i++) {
                        // Ensure consistent bar height regardless of volume
                        // Further reduced height multiplier to make bars less intense
                        const barHeight = 30 + (dataArray[i] * 0.5);
                        
                        // Calculate x position to ensure full width coverage including edges
                        // This formula ensures the first bar starts at x=0 and the last bar ends at canvas.width
                        // Added spacing between bars to prevent overlapping
                        const x = i * (canvas.width - barWidth) / (useBars - 1);
                        
                        // Bottom bars - constantly changing colors
                        const bottomHue = (Date.now() / 20 + i * 10) % 360; // Dynamic color change
                        ctx.fillStyle = `hsl(${bottomHue}, 100%, 50%)`;
                        
                        // Draw bottom bars with fixed width
                        ctx.beginPath();
                        ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                        ctx.fill();
                        
                        // Top bars - constantly changing colors with offset from bottom
                        const topHue = (Date.now() / 20 + i * 10 + 180) % 360; // Dynamic color change with offset
                        ctx.fillStyle = `hsl(${topHue}, 100%, 50%)`;
                        
                        // Draw top bars (not mirrored, but independent)
                        ctx.beginPath();
                        ctx.fillRect(x, 0, barWidth, barHeight);
                        ctx.fill();
                    
                    // Add extra bars at the edges to ensure full coverage
                    const edgeBarHeight = 80; // Reduced height for less intensity
                    
                    // Bottom edge bars - with constantly changing colors
                    // Left bottom edge - constantly changing color
                    const leftBottomEdgeHue = (Date.now() / 15) % 360;
                    ctx.fillStyle = `hsl(${leftBottomEdgeHue}, 100%, 50%)`;
                    ctx.beginPath();
                    ctx.fillRect(0, canvas.height - edgeBarHeight, barWidth, edgeBarHeight);
                    ctx.fill();
                    
                    // Right bottom edge - constantly changing color with offset
                    const rightBottomEdgeHue = (Date.now() / 15 + 120) % 360; // 120 degree offset
                    ctx.fillStyle = `hsl(${rightBottomEdgeHue}, 100%, 50%)`;
                    ctx.beginPath();
                    ctx.fillRect(canvas.width - barWidth, canvas.height - edgeBarHeight, barWidth, edgeBarHeight);
                    ctx.fill();
                    
                    // Top edge bars - with constantly changing colors
                    // Left top edge - constantly changing color
                    const leftTopEdgeHue = (Date.now() / 10 + 60) % 360; // 60 degree offset, faster change
                    ctx.fillStyle = `hsl(${leftTopEdgeHue}, 100%, 50%)`;
                    ctx.beginPath();
                    ctx.fillRect(0, 0, barWidth, edgeBarHeight);
                    ctx.fill();
                    
                    // Right top edge - constantly changing color with offset
                    const rightTopEdgeHue = (Date.now() / 10 + 240) % 360; // 240 degree offset, faster change
                    ctx.fillStyle = `hsl(${rightTopEdgeHue}, 100%, 50%)`;
                    ctx.beginPath();
                    ctx.fillRect(canvas.width - barWidth, 0, barWidth, edgeBarHeight);
                    ctx.fill();
                    }
                    
                    // Draw enhanced waveform with glow and dynamic effects
                    ctx.beginPath();
                    ctx.lineWidth = 3 + bassIntensity * 2; // Dynamic line width based on bass
                    
                    // Add glow effect to waveform
                    ctx.shadowBlur = 8 + 5 * midIntensity;
                    ctx.shadowColor = `hsl(${Date.now() / 10 % 360}, 100%, 70%)`;
                    
                    // Use more vibrant color with faster changes
                    ctx.strokeStyle = `hsl(${Date.now() / 10 % 360}, 100%, ${65 + 15 * Math.sin(Date.now() / 300)}%)`;
                    
                    // Draw waveform with smoother sampling (skip some points for performance)
                    const sliceWidth = canvas.width / (timeDataArray.length / 2); // Use half the points for better performance
                    let x = 0;
                    
                    for (let i = 0; i < timeDataArray.length; i += 2) { // Skip every other point
                        // Add some dynamic variation to the waveform
                        const v = (timeDataArray[i] / 128.0) + 0.05 * Math.sin((i / timeDataArray.length) * Math.PI * 10 + Date.now() / 1000);
                        const y = v * canvas.height / 2;
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            // Use quadratic curves for smoother waveform
                            if (i < timeDataArray.length - 2) {
                                const nextX = x + sliceWidth;
                                const nextV = (timeDataArray[i+2] / 128.0) + 0.05 * Math.sin(((i+2) / timeDataArray.length) * Math.PI * 10 + Date.now() / 1000);
                                const nextY = nextV * canvas.height / 2;
                                const cpX = x + sliceWidth / 2;
                                const cpY = (y + nextY) / 2;
                                ctx.quadraticCurveTo(cpX, cpY, nextX, nextY);
                                x = nextX;
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        
                        x += sliceWidth;
                    }
                    
                    ctx.lineTo(canvas.width, canvas.height / 2);
                    ctx.stroke();
                    
                    // Reset shadow
                    ctx.shadowBlur = 0;
                    
                    // Create enhanced circular visualizer with more impressive effects
                    // Calculate main circle radius based on audio intensity for more dynamic sizing
                    const baseMainRadius = Math.min(canvas.width, canvas.height) * 0.25; // Base size relative to canvas
                    const mainCircleRadius = baseMainRadius * (0.8 + 0.3 * (Math.max(...dataArray) / 255));
                    
                    // Define center point for consistent positioning
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    // Create more impressive glow effect
                    ctx.shadowBlur = 20 + 10 * bassIntensity;
                    ctx.shadowColor = `hsl(${(Math.max(...dataArray) + Date.now() / 10) % 360}, 100%, 60%)`;
                    
                    // Main circle with enhanced gradient
                    const circleGradient = ctx.createRadialGradient(
                        centerX, centerY, 0,
                        centerX, centerY, mainCircleRadius
                    );
                    
                    // Add more color stops for a more complex, vibrant gradient
                    const baseHue = (Date.now() / 30) % 360;
                    circleGradient.addColorStop(0, `hsla(${baseHue}, 100%, 75%, 0.3)`);
                    circleGradient.addColorStop(0.2, `hsla(${(baseHue + 60) % 360}, 100%, 70%, 0.25)`);
                    circleGradient.addColorStop(0.4, `hsla(${(baseHue + 120) % 360}, 100%, 65%, 0.2)`);
                    circleGradient.addColorStop(0.6, `hsla(${(baseHue + 180) % 360}, 100%, 60%, 0.15)`);
                    circleGradient.addColorStop(0.8, `hsla(${(baseHue + 240) % 360}, 100%, 55%, 0.1)`);
                    circleGradient.addColorStop(1, `hsla(${(baseHue + 300) % 360}, 100%, 50%, 0.05)`);
                    
                    // Draw main circle
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, mainCircleRadius, 0, Math.PI * 2);
                    ctx.fillStyle = circleGradient;
                    ctx.fill();
                    
                    // Add double stroke effect for more visual interest
                    // Inner stroke
                    ctx.strokeStyle = `hsl(${(baseHue + 180) % 360}, 100%, 60%)`;
                    ctx.lineWidth = 4 + bassIntensity * 6; // Dynamic line width
                    ctx.stroke();
                    
                    // Outer stroke (slightly larger)
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, mainCircleRadius + 5 + 3 * Math.sin(Date.now() / 300), 0, Math.PI * 2);
                    ctx.strokeStyle = `hsla(${baseHue}, 100%, 70%, ${0.6 + 0.4 * Math.sin(Date.now() / 500)})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Add pulsing outer ring for extra effect
                    ctx.beginPath();
                    const pulseAmount = 10 + 8 * Math.sin(Date.now() / 600);
                    ctx.arc(centerX, centerY, mainCircleRadius + pulseAmount, 0, Math.PI * 2);
                    ctx.strokeStyle = `hsla(${(baseHue + 120) % 360}, 100%, 80%, ${0.2 + 0.2 * Math.sin(Date.now() / 400)})`;
                    ctx.lineWidth = 1.5 + bassIntensity * 2;
                    ctx.stroke();
                    
                    // Reset shadow for other elements
                    ctx.shadowBlur = 0;
                    
                    // Use the already defined centerX and centerY variables for perfect alignment
                    
                    // Enhanced inner circles with perfect centering and cooler effects
                    for (let i = 1; i <= 7; i++) { // Increased to 7 circles for more visual interest
                        const freqSection = Math.floor(dataArray.length / 7);
                        const sectionAvg = dataArray.slice(freqSection * (i-1), freqSection * i)
                            .reduce((a, b) => a + b, 0) / freqSection;
                        
                        // Calculate radius with more variation and responsiveness
                        // Use a more consistent formula to ensure circles are properly sized relative to each other
                        const baseRadius = mainCircleRadius * (0.85 - (i * 0.1));
                        const radius = baseRadius * (0.8 + 0.4 * (sectionAvg / 255));
                        
                        // Add glow effect that varies by circle but is more intense
                        ctx.shadowBlur = 15 + (7-i) * 3; // More glow for outer circles
                        ctx.shadowColor = `hsl(${(sectionAvg + i * 51.4 + Date.now() / (10 + i * 5)) % 360}, 100%, 60%)`;
                        
                        // Draw perfectly centered circle
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                        
                        // More vibrant colors with higher saturation and luminosity
                        const hue = (sectionAvg + i * 51.4 + Date.now() / (10 + i * 5)) % 360;
                        ctx.strokeStyle = `hsl(${hue}, 100%, ${60 + 15 * Math.sin(Date.now() / 500)}%)`;
                        
                        // Vary line width for more visual interest - thicker lines for outer circles
                        ctx.lineWidth = 3 + (7-i) * 0.5 + Math.sin(Date.now() / (300 + i * 100)) * 1.5;
                        ctx.stroke();
                        
                        // Add subtle fill for more dimension - more transparent for inner circles
                        const fillOpacity = 0.03 + (0.02 * (7-i)) + 0.03 * Math.sin(Date.now() / 800);
                        ctx.fillStyle = `hsla(${hue}, 100%, 70%, ${fillOpacity})`;
                        ctx.fill();
                        
                        // Add pulsing ring effect for every other circle
                        if (i % 2 === 0) {
                            const pulseRadius = radius + 5 * Math.sin(Date.now() / (500 + i * 100));
                            ctx.beginPath();
                            ctx.arc(centerX, centerY, pulseRadius, 0, Math.PI * 2);
                            ctx.strokeStyle = `hsla(${(hue + 180) % 360}, 100%, 70%, ${0.3 + 0.2 * Math.sin(Date.now() / 600)})`;
                            ctx.lineWidth = 1.5;
                            ctx.stroke();
                        }
                    }
                    
                    // Reset shadow for other elements
                    ctx.shadowBlur = 0;
                    
                    // Update cat positions based on music
                    cats.forEach(cat => {
                        // Increase velocity based on bass (reduced multiplier for slower movement)
                        const speedMultiplier = 0.7 + bassIntensity * 2; // Reduced from 1+3 to 0.7+2
                        
                        // Update position
                        let x = parseFloat(cat.style.left);
                        let y = parseFloat(cat.style.top);
                        
                        // Handle parsing issues
                        if (isNaN(x)) x = Math.random() * 100;
                        if (isNaN(y)) y = Math.random() * 100;
                        
                        x += cat.vx * speedMultiplier;
                        y += cat.vy * speedMultiplier;
                        
                        // Bounce off edges with more dynamic color flash
                        if (x < 0 || x > 100) {
                            cat.vx *= -1;
                            x = Math.max(0, Math.min(100, x));
                            // More vibrant color flash with time-based hue
                            cat.style.filter = `drop-shadow(0 0 25px hsl(${(Date.now() / 10) % 360}, 100%, 60%))`;
                            setTimeout(() => {
                                cat.style.filter = 'drop-shadow(0 0 10px rgba(255, 255, 255, 0.7))';
                            }, 300);
                        }
                        
                        if (y < 0 || y > 100) {
                            cat.vy *= -1;
                            y = Math.max(0, Math.min(100, y));
                            // More vibrant color flash with time-based hue
                            cat.style.filter = `drop-shadow(0 0 25px hsl(${(Date.now() / 10 + 180) % 360}, 100%, 60%))`;
                            setTimeout(() => {
                                cat.style.filter = 'drop-shadow(0 0 10px rgba(255, 255, 255, 0.7))';
                            }, 300);
                        }
                        
                        // Occasionally flash cats even when not bouncing (about 1% chance per frame)
                        if (Math.random() < 0.01) {
                            // Get midIntensity and trebleIntensity from the already defined variables
                            const localMidIntensity = midAvg / 255;
                            const localTrebleIntensity = trebleAvg / 255;
                            
                            // More impressive glow effect with dynamic size based on bass intensity
                            const glowSize = 15 + Math.floor(bassIntensity * 25);
                            const glowColor = `hsl(${(Date.now() / 5) % 360}, 100%, 70%)`;
                            
                            // Apply enhanced visual effects
                            cat.style.filter = `drop-shadow(0 0 ${glowSize}px ${glowColor})`;
                            cat.style.transform = `rotate(${cat.rotation}deg) scale(${1.1 + bassIntensity * 0.4}) skew(${localMidIntensity * 10}deg, ${localTrebleIntensity * 10}deg)`;
                            
                            // Reset after a short delay with dynamic duration
                            setTimeout(() => {
                                cat.style.filter = 'drop-shadow(0 0 10px rgba(255, 255, 255, 0.7))';
                                cat.style.transform = `rotate(${cat.rotation}deg) scale(${1 + bassIntensity * 0.5}) skew(${localMidIntensity * 10}deg, ${localTrebleIntensity * 10}deg)`;
                            }, 200 + Math.floor(bassIntensity * 300));
                        }
                        
                        // Apply position
                        cat.style.left = `${x}vw`;
                        cat.style.top = `${y}vh`;
                        
                        // Rotate and scale based on music frequencies
                        // Use the already calculated values from above
                        const localMidIntensity = midAvg / 255;
                        const localTrebleIntensity = trebleAvg / 255;
                        
                        cat.rotation += cat.rotationSpeed * (1 + bassIntensity);
                        cat.style.transform = `rotate(${cat.rotation}deg) scale(${1 + bassIntensity * 0.5}) skew(${localMidIntensity * 10}deg, ${localTrebleIntensity * 10}deg)`;
                        
                        // Pulse opacity with music
                        cat.style.opacity = 0.3 + bassIntensity * 0.7;
                    });
                    
                    // Animate confetti
                    document.querySelectorAll('.confetti').forEach(confetti => {
                        let x = parseFloat(confetti.style.left);
                        let y = parseFloat(confetti.style.top);
                        
                        // Handle parsing issues
                        if (isNaN(x)) x = Math.random() * window.innerWidth;
                        if (isNaN(y)) y = 0;
                        
                        // Apply gravity and wind
                        confetti.vy += 0.1; // Gravity
                        confetti.vx += (Math.random() - 0.5) * 0.1; // Random wind
                        
                        // Apply bass effect to confetti
                        const confettiSpeedMultiplier = 1 + bassIntensity * 2;
                        
                        x += confetti.vx * confettiSpeedMultiplier;
                        y += confetti.vy * confettiSpeedMultiplier;
                        
                        // Rotate confetti
                        confetti.rotation += confetti.rotationSpeed;
                        
                        // Apply position and rotation
                        confetti.style.left = `${x}px`;
                        confetti.style.top = `${y}px`;
                        confetti.style.transform = `rotate(${confetti.rotation}deg)`;
                        
                        // Remove if out of view
                        if (y > window.innerHeight + 100) {
                            confetti.remove();
                        }
                    });
                }
            }
            
            // Handle window resize
            window.addEventListener('resize', function() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });
        });
    </script>
</body>
</html>